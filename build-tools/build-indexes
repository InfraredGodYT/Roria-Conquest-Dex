#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..');
process.chdir(root);

// ✅ Load LOCAL compiled data only
const {BattlePokedex}   = require('../data/pokedex');
const {BattleMovedex}   = require('../data/movedex');
const {BattleItems}     = require('../data/items');
const {BattleAbilities} = require('../data/abilities');
const {BattleTypeChart} = require('../data/typechart');

// ✅ Load local typechart (or define manually if missing)
const oldIndex = require("../client/play.pokemonshowdown.com/data/search-index.js");

// ✅ Minimal toID replacement (Showdown-compatible)
function toID(text) {
	return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '');
}

console.log("Building `play.pokemonshowdown.com/data/search-index.js`...");

let index = [];

index = index.concat(Object.keys(BattlePokedex).map(x => x + ' pokemon'));
index = index.concat(Object.keys(BattleMovedex).map(x => x + ' move'));
index = index.concat(Object.keys(BattleItems).map(x => x + ' item'));
index = index.concat(Object.keys(BattleAbilities).map(x => x + ' ability'));
index = index.concat(Object.keys(BattleTypeChart).map(x => toID(x) + ' type'));

index = index.concat(['physical', 'special', 'status'].map(x => toID(x) + ' category'));
index = index.concat([
	'monster','water1','bug','flying','field','fairy','grass','humanlike','water3',
	'mineral','amorphous','water2','ditto','dragon','undiscovered',
].map(x => toID(x) + ' egggroup'));
index = index.concat([
	'ou','uu','ru','nu','pu','zu','lc','nfe','uber', "uuber",
	'uubl','rubl','nubl','publ','zubl',
].map(x => toID(x) + ' tier'));

const BattleArticleTitles = {};

try {
	for (const file of fs.readdirSync('./articles/')) {
		if (file.endsWith('.md')) {
			const id = file.slice(0, -3);
			const contents = '' + fs.readFileSync('./articles/' + file);
			if (contents.startsWith('# ')) {
				const title = contents.slice(2, contents.indexOf('\n'));
				//if (title !== id.charAt(0).toUpperCase() + id.slice(1)) {
					BattleArticleTitles[id] = title;
				//}
			}
			index.push('' + id + ' article');
		}
	}
} catch(e) {
	console.log('\n(WARNING: NO ARTICLES) ' + e.stack);
}
index.push('pokemon article');
index.push('moves article');

// ✅ Alias generator (Dex-free)
function generateAlias(id, name, type) {
	const fullSplit = name.split(/ |-/).map(toID);
	if (fullSplit.length < 2) return;

	const fullAcronym =
		fullSplit.map(x => x.charAt(0)).join('') +
		fullSplit.at(-1).slice(1);

	index.push(`${fullAcronym} ${type} ${id} 0`);

	for (let i = 1; i < fullSplit.length; i++) {
		index.push(
			`${fullSplit.slice(i).join('')} ${type} ${id} ${
				fullSplit.slice(0, i).join('').length
			}`
		);
	}
}

// ✅ Pokémon aliases
for (const id in BattlePokedex) {
	const mon = BattlePokedex[id];
	if (mon.isCosmeticForme) continue;
	generateAlias(id, mon.name, 'pokemon');
}

// ✅ Move aliases
for (const id in BattleMovedex) {
	generateAlias(id, BattleMovedex[id].name, 'move');
}

// ✅ Item aliases
for (const id in BattleItems) {
	generateAlias(id, BattleItems[id].name, 'item');
}

// ✅ Ability aliases
for (const id in BattleAbilities) {
	generateAlias(id, BattleAbilities[id].name, 'ability');
}

// ✅ Ultra Beast hardcodes (official compatibility)
const ultraBeasts = {
	ub01symbiont: "nihilego",
	ub02absorption: "buzzwole",
	ub02beauty: "pheromosa",
	ub03lightning: "xurkitree",
	ub04blade: "kartana",
	ub04blaster: "celesteela",
	ub05glutton: "guzzlord",
	ubburst: "blacephalon",
	ubassembly: "stakataka",
	ubadhesive: "poipole",
	ubstinger: "naganadel",
};
for (const [ub, id] of Object.entries(ultraBeasts)) {
	index.push(`${ub} pokemon ${id} 0`);
}

// ✅ Sort and finalize
index.sort();

const BattleSearchIndex = index.map(x => {
	const parts = x.split(' ');
	if (parts.length > 3) {
		parts[3] = Number(parts[3]);
		parts[2] = index.indexOf(parts[2] + ' ' + parts[1]);
	}
	return parts;
});

// ✅ Type counts
const BattleSearchIndexOffset = BattleSearchIndex.map(entry => {
	const id = entry[0];
	let name = '';
	switch (entry[1]) {
	case 'pokemon': name = BattlePokedex[id]?.name; break;
	case 'move': name = BattleMovedex[id]?.name; break;
	case 'item': name = BattleItems[id]?.name; break;
	case 'ability': name = BattleAbilities[id]?.name; break;
	case 'article': name = BattleArticleTitles[id] || ''; break;
	}

	if (!name) return '';

	let res = '';
	let nonAlnum = 0;
	for (let i = 0, j = 0; i < id.length; i++, j++) {
		while (!/[a-zA-Z0-9]/.test(name[j])) {
			j++;
			nonAlnum++;
		}
		res += nonAlnum;
	}
	if (nonAlnum) return res;
	return '';
});

const BattleSearchCountIndex = {};
for (const type in BattleTypeChart) {
	BattleSearchCountIndex[type + ' move'] = Object.keys(BattleMovedex)
		.filter(id => (BattleMovedex[id].type === type)).length;
}

for (const type in BattleTypeChart) {
	BattleSearchCountIndex[type + ' pokemon'] = Object.keys(BattlePokedex)
		.filter(id => (
			BattlePokedex[id].isCosmeticForme &&
			BattlePokedex[id].types && 
			BattlePokedex[id].types.indexOf(type) >= 0
		)).length;
}

// ✅ Output exactly like Showdown
let buf = '// DO NOT EDIT - automatically built with build-tools/build-indexes\n\n';
buf += 'exports.BattleSearchIndex = ' + JSON.stringify(BattleSearchIndex) + ';\n\n';
buf += 'exports.BattleSearchIndexOffset = ' + JSON.stringify(BattleSearchIndexOffset) + ';\n\n';
buf += 'exports.BattleSearchCountIndex = ' + JSON.stringify(BattleSearchCountIndex) + ';\n\n';
buf += 'exports.BattleArticleTitles = ' + JSON.stringify(BattleArticleTitles) + ';\n\n';

fs.writeFileSync(
	'./client/play.pokemonshowdown.com/data/search-index.js',
	buf,
	'utf8'
);

console.log("DONE");
